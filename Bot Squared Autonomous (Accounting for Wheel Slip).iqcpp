{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\ncontroller Controller = controller();\nmotor FL = motor(PORT1, false);\nmotor FR = motor(PORT12, true);\nmotor SF = motor(PORT6, false);\nmotor SB = motor(PORT7, true);\ntouchled FLLight = touchled(PORT4);\ntouchled FRLight = touchled(PORT5);\ntouchled BLLight = touchled(PORT3);\ntouchled BRLight = touchled(PORT2);\nmotor Vertical = motor(PORT8, true);\nmotor Claw = motor(PORT9, false);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n// define variables used for controlling motors based on controller inputs\nbool eButtonsControlMotorsStopped = true;\nbool fButtonsControlMotorsStopped = true;\n\n// define a task that will handle monitoring inputs from Controller\nint rc_auto_loop_function_Controller() {\n  // process the controller input every 20 milliseconds\n  // update the motors based on the input values\n  while(true) {\n    if(RemoteControlCodeEnabled) {\n      // check the ButtonEUp/ButtonEDown status to control Claw\n      if (Controller.ButtonEUp.pressing()) {\n        Claw.spin(forward);\n        eButtonsControlMotorsStopped = false;\n      } else if (Controller.ButtonEDown.pressing()) {\n        Claw.spin(reverse);\n        eButtonsControlMotorsStopped = false;\n      } else if (!eButtonsControlMotorsStopped) {\n        Claw.stop();\n        // set the toggle so that we don't constantly tell the motor to stop when the buttons are released\n        eButtonsControlMotorsStopped = true;\n      }\n      // check the ButtonFUp/ButtonFDown status to control Vertical\n      if (Controller.ButtonFUp.pressing()) {\n        Vertical.spin(forward);\n        fButtonsControlMotorsStopped = false;\n      } else if (Controller.ButtonFDown.pressing()) {\n        Vertical.spin(reverse);\n        fButtonsControlMotorsStopped = false;\n      } else if (!fButtonsControlMotorsStopped) {\n        Vertical.stop();\n        // set the toggle so that we don't constantly tell the motor to stop when the buttons are released\n        fButtonsControlMotorsStopped = true;\n      }\n    }\n    // wait before repeating the process\n    wait(20, msec);\n  }\n  return 0;\n}\n\ntask rc_auto_loop_task_Controller(rc_auto_loop_function_Controller);\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// --- AUTONOMOUS RECORDING & REPLAY CODE START ---\n\n// --- Configuration and Variables ---\n// Maximum recording time is 90 seconds (1.5 minutes) at a constant polling interval of 40ms.\n// 90,000ms / 40ms = 2250 frames of information\nconst int MAX_FRAMES = 2250;\nconst double MAX_RECORD_SECONDS = 90.0;\nconst int RECORD_INTERVAL_MS = 40;\n\n// Struct to hold the state of the controller at a single point in time\nstruct RobotState {\n  int axisB;\n  int axisC;\n  int axisD;\n  bool btnEUp;\n  bool btnEDown;\n  bool btnFUp;\n  bool btnFDown;\n};\n\n// Array to store the sequence of recorded states\nRobotState recording[MAX_FRAMES];\n\n// State management variables\nbool isRecording = false;\nbool isReplaying = false;\nbool recordingAvailable = false;\nint recordingIndex = 0;\nint maxRecordingIndex = 0;\nvex::timer recordTimer; // Timer to manage recording duration\n\n// --- Replay Task ---\n// This function runs as a separate task to replay the recorded actions.\nint replayAuton() {\n  // Disable driver control during replay\n  RemoteControlCodeEnabled = false;\n  isReplaying = true;\n\n  // Indicate replay is in progress (optional: use a different color like blue)\n  BRLight.setColor(blue);\n\n  // Temporary variables for motor control logic during replay\n  bool replayEButtonsStopped = true;\n  bool replayFButtonsStopped = true;\n\n  // Loop through each recorded frame\n  for (int i = 0; i < maxRecordingIndex; i++) {\n    // --- Replay Drivetrain Control ---\n    int axisB_val = recording[i].axisB;\n    int axisC_val = recording[i].axisC;\n    int axisD_val = recording[i].axisD;\n\n    if (axisB_val == 0 && axisD_val == 0 && axisC_val == 0) {\n      FL.setStopping(hold); FR.setStopping(hold);\n      SF.setStopping(hold); SB.setStopping(hold);\n      FL.stop(); FR.stop(); SF.stop(); SB.stop();\n    } else {\n      FL.setStopping(coast); FR.setStopping(coast);\n      SF.setStopping(coast); SB.setStopping(coast);\n      FL.spin(forward); FR.spin(forward);\n      SF.spin(forward); SB.spin(forward);\n      if (axisB_val == 0) { // Tank/Arcade drive\n        FL.setVelocity(axisD_val, percent);\n        FR.setVelocity(axisD_val, percent);\n        SF.setVelocity(axisC_val, percent);\n        SB.setVelocity(axisC_val, percent);\n      } else { // Strafe\n        FL.setVelocity(axisB_val, percent);\n        FR.setVelocity(-axisB_val, percent);\n        SF.setVelocity(axisB_val, percent);\n        SB.setVelocity(-axisB_val, percent);\n      }\n    }\n\n    // --- Replay Claw Control (E Buttons) ---\n    if (recording[i].btnEUp) {\n      Claw.spin(forward);\n      replayEButtonsStopped = false;\n    } else if (recording[i].btnEDown) {\n      Claw.spin(reverse);\n      replayEButtonsStopped = false;\n    } else if (!replayEButtonsStopped) {\n      Claw.stop();\n      replayEButtonsStopped = true;\n    }\n\n    // --- Replay Vertical Lift Control (F Buttons) ---\n    if (recording[i].btnFUp) {\n      Vertical.spin(forward);\n      replayFButtonsStopped = false;\n    } else if (recording[i].btnFDown) {\n      Vertical.spin(reverse);\n      replayFButtonsStopped = false;\n    } else if (!replayFButtonsStopped) {\n      Vertical.stop();\n      replayFButtonsStopped = true;\n    }\n    \n    // Wait for the interval before processing the next frame\n    wait(RECORD_INTERVAL_MS, msec);\n  }\n\n  // --- Cleanup after replay is finished ---\n  FL.stop(); FR.stop(); SF.stop(); SB.stop();\n  Claw.stop(); Vertical.stop();\n  \n  // Re-enable driver control and reset state\n  isReplaying = false;\n  RemoteControlCodeEnabled = true;\n  BRLight.setColor(green); // Set light to show replay is available again\n\n  return 0;\n}\n// --- AUTONOMOUS RECORDING & REPLAY CODE END ---\n\n\n// User defined function\nvoid myblockfunction_Initialise();\n\n\n// User defined function\nvoid myblockfunction_Initialise() {\n  BrainInertial.setHeading(0.0, degrees);\n  FLLight.setColor(green);\n  FRLight.setColor(green);\n  // --- Set initial colors for Record and Replay LEDs ---\n  BLLight.setColor(green); // Green: Ready to record\n  BRLight.setColor(red);   // Red: No recording available to replay\n  \n  FLLight.setBrightness(100);\n  FRLight.setBrightness(100);\n  BLLight.setBrightness(100);\n  BRLight.setBrightness(100);\n  FL.setVelocity(0.0, percent);\n  FR.setVelocity(0.0, percent);\n  SF.setVelocity(0.0, percent);\n  SB.setVelocity(0.0, percent);\n  FL.setMaxTorque(200.0, percent);\n  FR.setMaxTorque(200.0, percent);\n  SF.setMaxTorque(200.0, percent);\n  SB.setMaxTorque(200.0, percent);\n  FL.setPosition(0.0, degrees);\n  FR.setPosition(0.0, degrees);\n  SF.setPosition(0.0, degrees);\n  SB.setPosition(0.0, degrees);\n  Vertical.setVelocity(100.0, percent);\n  Claw.setVelocity(100.0, percent);\n  Vertical.setMaxTorque(100.0, percent);\n  Vertical.setStopping(hold);\n  Claw.setStopping(hold);\n  FL.spin(forward);\n  FR.spin(forward);\n  SF.spin(forward);\n  SB.spin(forward);\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  myblockfunction_Initialise();\n  \n  while (true) {\n    // --- STATE MANAGEMENT LOGIC ---\n\n    // Check for RECORD START command from BL TouchLED\n    if (BLLight.pressing() && !isRecording && !isReplaying) {\n      isRecording = true;\n      recordingAvailable = false;\n      recordingIndex = 0;\n      \n      BLLight.setColor(red); // Indicate recording is active\n      BRLight.setColor(red); // Recording is not available for replay yet\n      \n      recordTimer.clear(); // Start the 90-second timer\n      wait(300, msec);     // Debounce to prevent accidental double-press\n    }\n\n    // Check for REPLAY START command from BR TouchLED\n    if (BRLight.pressing() && recordingAvailable && !isRecording && !isReplaying) {\n      // Start the replay in a new task so the main loop doesn't block\n      task replayTaskInstance(replayAuton);\n      wait(300, msec); // Debounce\n    }\n\n    // --- ACTIVE RECORDING LOGIC ---\n    if (isRecording) {\n      // Check for RECORD STOP conditions (manual press or timeout)\n      bool stop_pressed = BLLight.pressing();\n      bool timeout = recordTimer.time(sec) >= MAX_RECORD_SECONDS;\n\n      if (stop_pressed || timeout) {\n        // Stop recording\n        isRecording = false;\n        maxRecordingIndex = recordingIndex; // Save the number of recorded frames\n        \n        BLLight.setColor(green); // Set light back to ready state\n\n        if (maxRecordingIndex > 0) {\n          recordingAvailable = true;\n          BRLight.setColor(green); // Recording is now available for replay\n        } else {\n          recordingAvailable = false;\n          BRLight.setColor(red);   // No valid recording was made\n        }\n\n        if (stop_pressed) {\n          wait(300, msec); // Debounce if stopped manually\n        }\n      } \n      // If still recording, save a frame every 40ms\n      else if (recordTimer.time(msec) >= (recordingIndex * RECORD_INTERVAL_MS) && recordingIndex < MAX_FRAMES) {\n        recording[recordingIndex].axisB = Controller.AxisB.position();\n        recording[recordingIndex].axisC = Controller.AxisC.position();\n        recording[recordingIndex].axisD = Controller.AxisD.position();\n        recording[recordingIndex].btnEUp = Controller.ButtonEUp.pressing();\n        recording[recordingIndex].btnEDown = Controller.ButtonEDown.pressing();\n        recording[recordingIndex].btnFUp = Controller.ButtonFUp.pressing();\n        recording[recordingIndex].btnFDown = Controller.ButtonFDown.pressing();\n        recordingIndex++;\n      }\n    }\n    \n    // --- DRIVER CONTROL LOGIC (Drivetrain) ---\n    // This part runs continuously as long as a replay is not active.\n    if (!isReplaying) {\n      if (Controller.AxisB.position() == 0.0 && (Controller.AxisD.position() == 0.0 && Controller.AxisC.position() == 0.0)) {\n        FL.setStopping(hold);\n        FR.setStopping(hold);\n        SF.setStopping(hold);\n        SB.setStopping(hold);\n        FL.stop();\n        FR.stop();\n        SF.stop();\n        SB.stop();\n      }\n      else {\n        FL.setStopping(coast);\n        FR.setStopping(coast);\n        SF.setStopping(coast);\n        SB.setStopping(coast);\n        FL.spin(forward);\n        FR.spin(forward);\n        SF.spin(forward);\n        SB.spin(forward);\n        if (Controller.AxisB.position() == 0.0) {\n          FL.setVelocity((Controller.AxisD.position() * 1.0), percent);\n          FR.setVelocity((Controller.AxisD.position() * 1.0), percent);\n          SF.setVelocity((Controller.AxisC.position() * 1.0), percent);\n          SB.setVelocity((Controller.AxisC.position() * 1.0), percent);\n        }\n        else {\n          FL.setVelocity((Controller.AxisB.position() * 1.0), percent);\n          FR.setVelocity(((0.0 - Controller.AxisB.position()) * 1.0), percent);\n          SF.setVelocity((Controller.AxisB.position() * 1.0), percent);\n          SB.setVelocity(((0.0 - Controller.AxisB.position()) * 1.0), percent);\n        }\n      }\n    }\n    \n    wait(20, msec); // Keep the main loop responsive\n  }\n  return 0;\n}\n\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  whenStarted1();\n}","textLanguage":"cpp","robotConfig":[{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"Claw","eDir":"false","f":"Vertical","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[1],"name":"FL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"FR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"SF","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"SB","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"FLLight","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[5],"name":"FRLight","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[3],"name":"BLLight","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[2],"name":"BRLight","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[8],"name":"Vertical","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[9],"name":"Claw","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":1,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"target":"Physical"}